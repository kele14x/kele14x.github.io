<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>System Generator 上手</title>
  <style>
    html {
      line-height: 1.5;
      font-family: 'Source Han Serif SC', 'Noto Serif SC', Serif;
      font-size: 18px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">System Generator 上手</h1>
</header>
<p><a href="https://www.xilinx.com/products/design-tools/vivado/integration/sysgen.html">System Generator</a> 是 Xilinx Vivado 套件里的组件之一。它主要的作用是利用 Matlab 中的 Simulink 组件来完成 FPGA 设计，即将 Simulink 仿真模型 <strong>.slx</strong> 转换为 HDL 文件。具体来说，System Generator 为 Simulink 提供了一套 Block 库，这套 Block 库既可以完成功能仿真，也有对应的 HDL 描述/网表。这和 Matlab 自己的 <a href="https://www.mathworks.com/products/hdl-coder.html">HDL Coder</a> 类似，但由于是 Xilinx 为自己的 FPGA 写的 Block 库，能够比 HDL Coder 接触到更底层的设计，以便进行优化。更多关于两个工具的对比，可以参考 Matlab 的<a href="https://www.mathworks.com/tagteam/74244_92077v00_Xilinx_WhitePaper_final.pdf">这个文档</a>。</p>
<p>当然也是由于工作的原因，我开始接触这个工具，让我们先简单的看看它是否好用。</p>
<!--more-->
<h2 id="何时我们需要-system-generator">何时我们需要 System Generator</h2>
<p>System Generator (SysGen) 这个工具设计的初衷，自然是为了在一定程度上保证设计质量的前提下缩短完成 FPGA 设计的时间。传统的 FPGA 设计采用手写 HDL 来完成，但随着 FPGA 芯片规模的慢慢增大，设计也慢慢变得非常复杂。HDL 这样“汇编”级别的设计语言渐渐显得过于繁琐和效率低下。比如说 HDL 语言中没有定点运算（Fixed Point）库，导致进行运算时常需要注释每个数的类型（例如 <code>Fix_xx_xx</code>）,并且在类型转换时要小心的手动截位。</p>
<p>抽象层底低让 HDL 设计出来的电路有无以伦比的效率（好的设计），但复杂度和消耗的时间随规模呈指数增长。缩短设计周期首要自然是重用和延续稳定的设计（基于 IP），其次的方法就是利用工具进行自动 HDL 代码生成，即所谓的高层次综合。这种工具其实<a href="https://en.wikipedia.org/wiki/High-level_synthesis">很多</a>，但大部分都是面向企业用户，有很高的收费墙。SysGen 在其中算是比较容易接近到的了，毕竟 Matlab/Simulink 和 Vivado 套件都有试用版。</p>
<p>SysGen 的基本需求：</p>
<ul>
<li>Matlab</li>
<li>Simulink (Matlab 的组件)</li>
<li>Vivado System Edition</li>
</ul>
<p>Matlab 和 Vivado 具体版本的搭配有一些需求，这得参考官方文档。另外 Matlab 的一些常用工具箱，例如 DSP、Fixed-Point 等是否是必需我不大确定，当然是有则好。</p>
<p>如果你对 Vivado 套件熟悉的话，Xilinx 其实还有另外一个 HDL 生成工具叫 HLS：</p>
<figure>
<img src="/image/sysgen-vivado-ds.png" alt="Vivado 套件" /><figcaption aria-hidden="true">Vivado 套件</figcaption>
</figure>
<p>HLS 的主要作用是将 C/C++ （<em>.h, </em>.c, *.cpp）转换成 HDL。选择 C/C++ 自然是由于 C 语言的流行（很多人都会，很多算法都有相应的 C 实现）。但本质来说，C 这种行为描述语言和 HDL 这种结构描述语言还是有不小的差距。实际使用的时候，会发现尽管 HLS 已经足够聪明，但总有一些地方用户不得不通过调整语句（换个等效的说法）或者借助 directive 来进行修正。软件工程师写出来的 C 代码，几乎不可能不经修改就进行 HLS 综合。</p>
<p>而 SysGen 却与 HLS 不同，基于 Block 和输入输出的 Simulink 模型本身就和 FPGA 的结构相似。甚至可以说就是 RTL 的抽象描述——Simulink 里的一个 Block 可以自然的映射为 FPGA 中的一个模块；Simulink 模型中的时间轴就是 FPGA 中的时钟。</p>
<p>但这也不代表 SysGen 可以完成一个完整的 FPGA 设计。现代的 FPGA 芯片内资源非常复杂，使用场景也不尽相同，SysGen 则专门为数字信号处理（DSP）设计。更简单来说，SysGen 只能使用 Xilinx FPGA 中的 CLB、Memory、DSP48 这三种资源。正因为此，SysGen 生成的 HDL/网表一般作为模块被顶层 HDL 调用。SysGen 在整个 FPGA 工程中的地位，<a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_2/ug897-vivado-sysgen-user.pdf">UG897</a> 有更详细的解释，但可以简答的认为 SysGen 可以用来快速完成一个 DSP 模块。</p>
<h2 id="简单上手">简单上手</h2>
<h3 id="安装">安装</h3>
<p>SysGen 的安装比较简单：安装 Matlab，安装 Vivado System Edition，以管理员身份运行 <strong>System Generator 201x.x MATLAB Configurator</strong>，选择 Matlab 版本即可。然后从开始菜单运行 <strong>System Generator 201x.x</strong> 就会打开配置好关联的 Matlab。Matlab Console 会提示你 SysGen 已经内嵌：</p>
<figure>
<img src="/image/sysgen-matlab-console.png" alt="Matlab Console" /><figcaption aria-hidden="true">Matlab Console</figcaption>
</figure>
<p>然后打开 Simulink 里的 Simulink Library Browser 就能看到 SysGen 的 Block 库了：</p>
<figure>
<img src="/image/sysgen-simulink-library-browser.png" alt="Simulink Library Browser" /><figcaption aria-hidden="true">Simulink Library Browser</figcaption>
</figure>
<h3 id="简单的工程">简单的工程</h3>
<p>首先需要说明的是，Xilinx Blockset 中有三个“特别”的 Block： <strong>System Generator</strong>、<strong>Gateway In</strong>、<strong>Gateway Out</strong>。在简单的情况下，一个 Simulink 模型（即一个 *.slx 文件）生成一个 FPGA 模块，这个 Simulink 模型中至少包含一个 <strong>System Generator</strong>，一个 <strong>Gateway In</strong>，一个 <strong>Gateway Out</strong>。</p>
<figure>
<img src="/image/sysgen-must-block.png" alt="Must Block" /><figcaption aria-hidden="true">Must Block</figcaption>
</figure>
<p><strong>System Generator</strong> 用于配置工程的参数，并且提供 Sysgen 操作接口：</p>
<figure>
<img src="/image/sysgen-block.png" alt="Sysgen Generator" /><figcaption aria-hidden="true">Sysgen Generator</figcaption>
</figure>
<p><strong>Gateway In</strong> 代表 FPGA 模块的输入，<strong>Gateway Out</strong> 代表 FPGA 模块的输出。<strong>Gateway In</strong> 和 <strong>Gateway Out</strong> 之间的路径只能包含 Xilinx Blockset 中的模块，因为它们将会被用于生成 HDL。</p>
<p>以 Xilinx 的 <a href="http://www.xilinx.com/member/forms/download/design-license.html?cid=03131094-cc75-4b06-8410-f0be3ecad521&amp;filename=ug948-design-files.zip">SysGen 教程配套工程</a>中的 <strong>Lab1_2</strong> 为例，这可以说是一个典型的 SysGen 工程：</p>
<figure>
<img src="/image/sysgen-hdl-gen.png" alt="HDL Code Gen" /><figcaption aria-hidden="true">HDL Code Gen</figcaption>
</figure>
<p>图中 <strong>Gateway In</strong> 和 <strong>Gateway Out</strong> 之间是 FPGA 模块的设计——只有一个 FIR 滤波器。左侧是测试用的激励，右侧是示波器，用于观察测试输出。下方则是用纯 Siumlink 模块搭建的同样的滤波器，用于对比输出的误差。</p>
<p>在生成代码之前，首先要通过仿真来确认设计是正确的。点击 Siumlink 的开始按钮，Simulink 就会调用 <em>vivado.exe</em> 完成 Simulink 和 Vivado 的协同仿真。之后通过频谱仪就能观察到输出信号的特征。</p>
<figure>
<img src="/image/sysgen-sim-result.png" alt="仿真结果" /><figcaption aria-hidden="true">仿真结果</figcaption>
</figure>
<p>左侧为纯 Simulink 模块的输出信号的频谱，右侧为 SysGen 模块输出信号的频谱。对比可以看到量化和采样对信号带来的失真。确认设计无误后，双击打开 <strong>System Generator</strong> 模块，点击 <strong>Generate</strong>，稍等之后就能得到生成的 HDL：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Generated from Simulink block</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">library</span> IEEE;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> IEEE<span class="ot">.</span>std_logic_1164<span class="ot">.</span><span class="kw">all</span>;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">library</span> xil_defaultlib;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> xil_defaultlib<span class="ot">.</span>conv_pkg<span class="ot">.</span><span class="kw">all</span>;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="cf">entity</span> <span class="dv">lab1_2</span> <span class="kw">is</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">port</span> (</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    gateway_in <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>( <span class="dv">16</span><span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span> );</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    clk <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    gateway_out <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>( <span class="dv">36</span><span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span> )</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  );</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="cf">end lab1_2;</span></span></code></pre></div>
<p>可以看到 SysGen 中隐含了 <code>clk</code> 端口，用于提供模块的时钟输入。如果是多速率的设计，SysGen 中还会隐含 <code>ce</code> 即时钟使能端口。至此已经完整了一个简单模块的设计流程。</p>
<h3 id="时钟约束">时钟约束</h3>
<p>FPGA 中最重要的一个约束就是时钟速率，它被用于静态时序检查。与 HLS 类似，SysGen 中可以通过设置约束时钟速度，在代码生成之后还可以自动进行综合和实现，以便检查时序和资源情况。值得称道的是，SysGen 可以将时序路径和资源消耗对应到 Simulink 模型，也就是可以通过综合和实现之后的结果来指出是哪个连线或哪个模块造成了这条路径和这些资源消耗。</p>
<figure>
<img src="/image/sysgen-block2.png" alt="SysGen 约束" /><figcaption aria-hidden="true">SysGen 约束</figcaption>
</figure>
<h2 id="system-generator-生成的代码的质量">System Generator 生成的代码的质量？</h2>
<p>我们在使用 SysGen 这种工具的时候，我们可能会关心这个工具生成 HDL 代码的“质量”如何，实现的是否“优雅”。质量一般包含两个部分，其一是这个 HDL 代码可以跑多快，其二是这个 HDL 代码资源/功耗如何。在接触 SysGen 之前，我曾经觉得用工具生成的代码应该没有手写的 HDL 精简、高效（即优雅）。因为在将一个高度抽象的东西实现的过程中，机器经常会用很多机械式的、可笑的方法来完成。但用过了 HLS 和 SysGen 之后，我发现 Xilinx 的工程师在大部分的时候，还是会比我聪明；而在小部分的时候，我也可以亲手来告诉工具细节怎么处理。</p>
<p>让我们来看看 SysGen 的模块——SysGen 一共提供了 80 多个 Block，基本模块包括加法器、乘法器、延迟、逻辑运算等；高级的模块包括 FIR 数字滤波器、FFT、RS 编码等。基本模块的质量不用多说，它们就是最简单的单元，实现和常用的方式不会有区别；而高级模块，也都是经过验证的 IP Core，可能在适合实际场景中不是完全最优，当考虑到可以直接调用，也非常值得。</p>
<p>终极的情况下，我们也可以手动调用分立资源，包括寄存器、DSP48、RAM 等，来手动实现设计。因为这些底层资源在 SysGen 中也有模型。所以一般来说 SysGen 生成的代码完全能够达到手写 HDL 代码的优化程度，甚至能够完成 RTL 级的设计。在大部分情况下，不会存在工具的“天花板”。</p>
<h2 id="优势与不足">优势与不足</h2>
<p>最后，来简单的说一下试用感受吧：</p>
<p>优势：</p>
<ul>
<li>使用 Simulink 从更高层次设计模块</li>
<li>Simulink 中激励的产生和观察输出都很方便</li>
<li>必要时能够进行比较底层的设计</li>
<li>路径和资源分析非常直观</li>
</ul>
<p>不足：</p>
<ul>
<li>编译速度有点慢</li>
<li>slx 文件版本控制/团队协作比较困难</li>
<li>Matlab/Vivado 版本升级时对老设计有影响</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.xilinx.com/products/design-tools/vivado/integration/sysgen.html">SysGen 产品页面</a></li>
<li><a href="https://www.mathworks.com/tagteam/74244_92077v00_Xilinx_WhitePaper_final.pdf">Mathworks 白皮书</a></li>
<li><a href="https://en.wikipedia.org/wiki/High-level_synthesis">HLS on Wikipedia</a></li>
<li><a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_2/ug948-vivado-sysgen-tutorial.pdf">Xilinx 的 SysGen 教程</a></li>
<li><a href="http://www.xilinx.com/member/forms/download/design-license.html?cid=03131094-cc75-4b06-8410-f0be3ecad521&amp;filename=ug948-design-files.zip">Xilinx 的 SysGen 教程配套文件</a></li>
<li><a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_2/ug897-vivado-sysgen-user.pdf">Xilinx 的 SysGen 用户手册</a></li>
<li><a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_2/ug958-vivado-sysgen-ref.pdf">Xilinx 的 SysGen 参考手册</a></li>
<li><a href="https://www.xilinx.com/support/documentation-navigation/design-hubs/dh0014-vivado-system-generator-hub.html">Xilinx 的 SysGen Hub</a></li>
</ul>
</body>
</html>
