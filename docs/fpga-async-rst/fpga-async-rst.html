<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Asynchronous Reset</title>
  <style>
    html {
      line-height: 1.5;
      font-family: 'Source Han Serif SC', 'Noto Serif SC', Serif;
      font-size: 18px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Asynchronous Reset</h1>
</header>
<h2 id="the-problem-of-asynchronous-reset">The Problem of Asynchronous Reset</h2>
<p>If you have looked at Xilinx primitive library, there are 4 types of D Flip-Flops (FF). The differences between them depends on whether they have a synchronous/asynchronous or clear/preset pin. When writing HDL code, we can model an FF with async clear:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">always</span> <span class="op">@</span> <span class="op">(</span><span class="kw">posedge</span> clk <span class="dt">or</span> <span class="kw">posedge</span> arst<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>arst<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      data <span class="op">&lt;=</span> <span class="bn">1&#39;b0</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span> <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span>cen<span class="op">)</span> <span class="kw">begin</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      data <span class="op">&lt;=</span> din<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span></code></pre></div>
<p>Then you will get a FDCE after synthesis. The code is nothing special. Register <code>data</code> will be set (reset) to <code>1'b0</code> when <code>arst</code> is asserted, and back to normal operation if <code>arst</code> is de-asserted. Since reset have higher priority over clock, the <code>Q</code> output will be cleared even there is no clock.</p>
<p>But async reset is more complicated than expected. With a long reset period, we can ensure all registers are under reset. However, if async reset is released on the time near the clock edge, the register may enter a metastability state. The output will be unpredictable and may cause the design fail. So, even async reset have timing requirement similar with sync reset. This is a common misunderstanding for new designers.</p>
<p>The required known relationship between the clock and the async reset signal are called <strong>recovery and removal time</strong> checks. These checks are defined only for de-assertion of asynchronous reset.</p>
<p>To avoid the problem of async reset, we can divide the situation into two case:</p>
<h2 id="asynchronous-reset-is-need">Asynchronous Reset is Need</h2>
<p>For example, if you need to reset a specification region of logic before clock is ready (or even no clock), async reset is the only option. Some ASIC library may even only provide async reset Flip-Flops. In these cases, we usually use a asynchronous reset synchronizer (“asynchronous reset but synchronous release”).</p>
<figure>
<img src="fpga-async-rst-sync.png" alt="Asynchronous Reset, Synchronous Release" /><figcaption aria-hidden="true">Asynchronous Reset, Synchronous Release</figcaption>
</figure>
<p>When <code>src_arst</code> is assert, all registers and <code>dest_arst</code> are set to 1 immediately. After <code>src_arst</code> is de-assert. It takes serval clock tick for <code>dest_arst</code> to go back to 0. The register chain help cleanup the metastability cased by the unknown arrive time of async reset. At lease 2 FFs are need, more stages of pipeline improves.</p>
<p>Using clock gating would also help. After disable the clock and assert asynchronous reset, all registers are under reset, release reset, then feed clock again. Consider the possible unstable clock for first cycles, usually we still need this synchronizer.</p>
<h2 id="asynchronous-reset-could-be-replaced">Asynchronous Reset Could Be Replaced</h2>
<p>In most case, we can replace async reset with sync reset. In this case, a simple general single-bit CDC circuit will satisfy our requirement:</p>
<figure>
<img src="fpga-sync-rst-sync.png" alt="Synchronous Reset, Synchronous Release" /><figcaption aria-hidden="true">Synchronous Reset, Synchronous Release</figcaption>
</figure>
<p><code>dest_rst</code> will be asserted and de-asserted synchronously with <code>dest_clk</code>.</p>
</body>
</html>
