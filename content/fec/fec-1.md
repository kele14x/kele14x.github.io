---
title: FEC 简绍 - 1
date: 2025-12-17
---

在计算、电信、信息论和编码理论中，**ECC（Error Control Coding/Error Correction Coding）**，或者 **前向纠错（FEC/Forward Error Correction）** 或 **信道编码（Channel Coding）** 差不多说的都是同一个东西——一类用于在不可靠或噪声通信信道中数据传输信息并减少错误的技术。美国数学家 _理查德·卫斯里·汉明（Richard Wesley Hamming）_ 在 1940 年代开创了这一领域，并于 1950 年发明了第一个纠错码：**汉明（7, 4）码**。

[据说](https://en.wikipedia.org/wiki/Hamming_code)汉明 1940 年代末期在贝尔实验室工作，需要用到 Bell Model V 计算机。这是一台机电继电器式计算机，循环时间以秒为单位，通过打孔纸带输入数据和指令。纸带宽七分之八英寸，每行最多六个孔。计算机检测到错误时，机器会停止并闪烁灯光，在工作日时就会有操作员来纠正问题。但是在下班时间或周末没有操作员时，机器就只能能停在那里了。汉明经常在周末工作，被整得有点破防。因为检测到错误后就必须从头开始重新启动程序。在一次录音采访中汉明说：“该死的，如果机器可以检测到错误，为什么不能定位错误的位置并纠正它？”在接下来的几年里，他致力于纠错问题，开发了一系列越来越强大的算法。1950 年，他发表了现在被称为汉明码的内容，至今仍在 ECC 内存等应用中使用。

让我先从最简单的汉明（7, 4）码开始入门。

## 汉明（7, 4）码

### 概述

汉明（7, 4）码对每 4 个待编码的比特添加 3 个比特的校验码，变成 7 比特。这也是它为什么被称为（7, 4）编码。我们设这 4 个待编码的数据比特为 $[d_0, d_1, d_2, d_3]$。进行编码后，编码器添加的 3 个比特为 $[p_0, p_1, p_2]$。计算公式为（为方便说明和理解，相较于原始的论文有所修改）：

$$
\begin{align}
p_0 &= d_0 \oplus d_1 \oplus d_2 \\
p_1 &= d_1 \oplus d_2 \oplus d_3 \\
p_2 &= d_0 \oplus d_1 \oplus d_3 \\
\end{align}
$$

其中 $\oplus$ 为异或运算符。

得到的这 7 个比特会写在纸带上，计算机读取到信息之后会进行校验：

$$
\begin{align}
s_0 = d_0 \oplus d_1 \oplus d_2 \oplus p_0 \\
s_1 = d_1 \oplus d_2 \oplus d_3 \oplus p_1 \\
s_2 = d_0 \oplus d_1 \oplus d_3 \oplus p_2 \\
\end{align}
$$

$s_0, s_1, s_2$ 被称为校验的**伴随式**（Syndrome）。Syndrome 直译过来是“综合症”，有些时候也被翻译成“校验值”。之所以叫这个名字，是因为接下来的过程计算机就需要（并且仅需要）根据这 3 个比特判断读取到的数据是否有错误。有点像老中医把下脉就知道你身体哪儿出问题了。

显然，若传输过程中未出错，则 $s_0 = s_1 = s_2 = 0$。

现在来看当传输过程中出现了 1 比特错误会发生什么：假设错误位于 $d_0$，则 $s_0 = s_2 = 1, s_1 = 0$（注意：二进制比特的“一个错误”表示该比特被反转了），或者说 $[s_0, s_1, s_2] = [1, 0, 1]$。如果这 1 比特错误发生在校验位 $p_0$ 上，我们同样可以得到 $[s_0, s_1, s_2] = [1, 0, 0]$。

我们可以很容易枚举这 1 比特错误发生在不同位置时，产生的伴随式的值：

| 错误位置 | $[s_0, s_1, s_2]$ |
| -------- | ------------------------ |
| $d_0$    | $[1, 0, 1]$              |
| $d_1$    | $[1, 1, 1]$              |
| $d_2$    | $[1, 1, 0]$              |
| $d_3$    | $[0, 1, 1]$              |
| $p_0$    | $[1, 0, 0]$              |
| $p_1$    | $[0, 1, 0]$              |
| $p_2$    | $[0, 0, 1]$              |

因此假如只发生了 1 比特错误，那么计算机可以根据得到的伴随式的值，然后翻转对应比特来纠正。消息长度为 7，因此存在 7 个可能的 1 比特错误位置，加上无错误的情况，刚好可以用 3 比特来表示。换句话说，汉明（7, 4）码把每一个可能的 1 比特错误映射成不同的伴随式的值，这点非常巧妙。

那么如果发生了 2 比特或者更多的错误呢？汉明（7, 4）编码无能为力——这已经超过了它能够处理的情况。并且你可能已经发现，如果发生了 2 比特或者更多的错误，得到的伴随式的值和 1 比特错误时能够得到的伴随式的值是一样的。所以其实汉明（7, 4）编码其实并没有办法区分到底是错了 1 个比特还是错了很多个比特。甚至即便是算出来伴随式的值为 0，也不能说明没有错误，它也有可能是错了多个比特然后刚好凑巧把校验值凑成 0 了。但是由于发生 2 个或者更多比特错误终究概率更低，所以按照 1 比特错误纠正就好，毕竟对于汉明（7, 4）来说也没有更好的处理手段了。

### 矩阵形式

汉明 (7, 4) 码可以表示为可以写成矩阵形式，对应有生成矩阵与校验矩阵如下：

生成矩阵 $\bm{G}$：

$$
\bm{G} = \begin{bmatrix}
1,& 0,& 0,& 0,& 1,& 1,& 0\\
0,& 1,& 0,& 0,& 0,& 1,& 1\\
0,& 0,& 1,& 0,& 1,& 1,& 1\\
0,& 0,& 0,& 1,& 1,& 0,& 1\\
\end{bmatrix}
$$

编码计算公式：

$$
[d_3, d_2, d_1, d_0] \cdot \bm{G} = [d_3, d_2, d_1, d_0, p_2, p_1, p_0]
$$

校验矩阵 $\bm{H}$：

$$
\bm{H} = \begin{bmatrix}
1,& 0,& 1,& 1,& 1,& 0,& 0\\
1,& 1,& 1,& 0,& 0,& 1,& 0\\
0,& 1,& 1,& 1,& 0,& 0,& 1\\
\end{bmatrix}
$$

伴随式计算公式：

$$
[s_2, s_1, s_0]^T = [d_3, d_2, d_1, d_0, p_2, p_1, p_0] \cdot \bm{H}^T
$$

可以很容易验证 $\bm{G} \cdot \bm{H}^T = \bm{0}$，这是编解码非常重要的一个特征。

## 为什么 FEC 有效

再回到 FEC 的话题，为什么 FEC 能够不单单检测，还能纠正在数字通信系统中传输消息时发生的错误？因为编码器不仅传输信息符号，还传输额外的冗余符号。FEC 的核心思想是以冗余方式对消息进行编码，解码器使用冗余符号解读接收到的内容。冗余允许接收方不仅检测，并且可能纠正有限数量的错误。从通信的角度来说，FEC 通过将信息和噪声“平摊”到每个传输的符号上来工作，即使部分符号损坏，仍然可以从其他符号中提取原始消息。根据香农理论，使用更多带宽来传输更少的信息，就可以承受更多噪声。

与 FEC 相对的还有 BEC（Backward Error Correction/反向纠错，但基本没人这么叫）：接受方检测到错误之后请求发送方重传。显然相比于重传，FEC 的优点是不需要反向信道来发送重传请求，而缺点是会占用固定的信道带宽。

## FEC 的类型

FEC 或者说 ECC 大约可以分为两类：分组码（Block Coding）和卷积编码（Convolution Codding）。分组码将固定数量的消息符号映射到固定数量的编码符号。分组码独立处理每个数据块，因此它是一个无记忆系统。**卷积码**是一个有记忆系统，它也接受固定数量的消息符号并产生固定数量的编码符号。但其计算过程不仅取决于当前输入集，还取决于一些先前的输入符号。

一些常见的分组码包括：

- BCH 码：ECC 内存/硬盘/嵌入式系统
- Reed-Solomon（RS）码：光纤/以太网/RAID/DVB
- LDPC：Wi-Fi/5G 共享信道/DVB
- 极化码：5G 控制信道/物联网

一些常见卷积码有：

- Viterbi 码：GSM/WCDMA/卫星通信
- Turbo 码：卫星/3G/4G/WiMAX
